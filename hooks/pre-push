#!/bin/bash
# Pre-push hook â€” version check + post-push PyPI publish
#
# Flow:
#   1. Check version status (fast)
#   2. Interactive prompts if needed (version bump, publish decision)
#   3. Exit 0 â†’ git push proceeds immediately
#   4. Background job publishes to PyPI after push finishes

# No set -e: we handle errors explicitly to avoid blocking push

# Colors
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
DIM='\033[2m'
NC='\033[0m'

WANT_PUBLISH=false
REPO_DIR="$(pwd)"
REPO_NAME="$(basename "$REPO_DIR")"
PUBLISH_LOG="/tmp/${REPO_NAME}-publish-$$.log"

# Safe read: falls back to default if /dev/tty is unavailable (SSH drop, IDE, etc.)
safe_read() {
    local varname="$1"
    local default="$2"
    if [ -t 0 ] || [ -c /dev/tty ] 2>/dev/null; then
        read -r "$varname" </dev/tty 2>/dev/null || eval "$varname=\"$default\""
    else
        eval "$varname=\"$default\""
    fi
}

# Auto-find _version.py in repo
find_version_files() {
    find . -maxdepth 4 -name '_version.py' -not -path '*/node_modules/*' -not -path '*/.git/*' -not -path '*/dist/*' -not -path '*/.egg-info/*' -not -path '*/build/*' 2>/dev/null
}

# Function to update version (supports both static and dynamic versioning)
update_version() {
    local old_version="$1"
    local new_version="$2"
    local updated=false

    # Try to update pyproject.toml (static version)
    if grep -q '^version = "' pyproject.toml 2>/dev/null; then
        sed -i "s/version = \"${old_version}\"/version = \"${new_version}\"/" pyproject.toml
        git add pyproject.toml
        updated=true
    fi

    # Try to update _version.py (dynamic version)
    while IFS= read -r VERSION_FILE; do
        if [ -f "$VERSION_FILE" ] && grep -q '__version__ = "' "$VERSION_FILE" 2>/dev/null; then
            sed -i "s/__version__ = \"${old_version}\"/__version__ = \"${new_version}\"/" "$VERSION_FILE"
            git add "$VERSION_FILE"
            updated=true
        fi
    done < <(find_version_files)

    if [ "$updated" = false ]; then
        echo -e "${RED}âœ— Failed to update version (no version file found)${NC}"
        return 1
    fi

    return 0
}

# Schedule PyPI publish to run AFTER push completes (background)
schedule_post_push_publish() {
    local version="$1"
    local package="$2"

    if ! command -v sage-pypi-publisher &> /dev/null; then
        echo -e "${YELLOW}âš  sage-pypi-publisher not found, skipping auto-publish${NC}"
        echo -e "${DIM}  Install: pip install isage-pypi-publisher${NC}"
        return
    fi

    echo -e "${GREEN}ðŸ“¦ PyPI publish scheduled (runs after push)${NC}"
    echo -e "${DIM}  Log: tail -f ${PUBLISH_LOG}${NC}"

    # Fork background job - waits for git push (parent of pre-push) to finish
    (
        GIT_PID="$PPID"
        while kill -0 "$GIT_PID" 2>/dev/null; do
            sleep 1
        done
        sleep 1

        cd "$REPO_DIR" || exit 1

        {
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ðŸ“¦ Post-push: Building ${package} ${version}..."
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

            rm -rf dist/ build/ *.egg-info 2>/dev/null || true

            if sage-pypi-publisher build . --upload --no-dry-run; then
                echo ""
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo "âœ“ Successfully uploaded ${package} ${version} to PyPI"
                echo "ðŸ”— https://pypi.org/project/${package}/${version}/"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            else
                echo ""
                echo "âœ— Failed to upload to PyPI (exit code: $?)"
                echo "  Re-run manually: sage-pypi-publisher build . --upload --no-dry-run"
            fi
        } >> "$PUBLISH_LOG" 2>&1

        # Print summary to terminal (user sees it after push output)
        if grep -q "Successfully uploaded" "$PUBLISH_LOG" 2>/dev/null; then
            echo -e "\n${GREEN}âœ“ PyPI: ${package} ${version} published${NC}"
        else
            echo -e "\n${RED}âœ— PyPI publish failed. See: ${PUBLISH_LOG}${NC}"
        fi
    ) &
    disown
}

# --- Main Logic ---

# Extract package name from pyproject.toml
if [ ! -f pyproject.toml ]; then
    exit 0
fi

PACKAGE_NAME=$(grep -oP '^name = "\K[^"]+' pyproject.toml 2>/dev/null || echo "unknown")

# Try to get version from pyproject.toml (static version)
CURRENT_VERSION=$(grep -oP '^version = "\K[^"]+' pyproject.toml 2>/dev/null || true)

# If not found, try _version.py (dynamic version)
if [ -z "$CURRENT_VERSION" ] || [ "$CURRENT_VERSION" = "unknown" ]; then
    while IFS= read -r VERSION_FILE; do
        if [ -f "$VERSION_FILE" ]; then
            CURRENT_VERSION=$(grep -oP '__version__ = "\K[^"]+' "$VERSION_FILE" 2>/dev/null || true)
            if [ -n "$CURRENT_VERSION" ]; then
                break
            fi
        fi
    done < <(find_version_files)
fi

if [ -z "$CURRENT_VERSION" ] || [ "$CURRENT_VERSION" = "unknown" ]; then
    exit 0
fi

if ! git rev-parse HEAD~1 >/dev/null 2>&1; then
    exit 0
fi

# Check if version was updated in recent commits
VERSION_UPDATED=false
for i in {1..5}; do
    if git diff HEAD~$i HEAD -- pyproject.toml 2>/dev/null | grep -q '^[+-]version = '; then
        VERSION_UPDATED=true
        break
    fi
done

if [ "$VERSION_UPDATED" = false ]; then
    VERSION_FILES_FOR_DIFF=$(find_version_files | tr '\n' ' ')
    if [ -n "$VERSION_FILES_FOR_DIFF" ]; then
        for i in {1..5}; do
            if git diff HEAD~$i HEAD -- $VERSION_FILES_FOR_DIFF 2>/dev/null | grep -q '^[+-]__version__ = '; then
                VERSION_UPDATED=true
                break
            fi
        done
    fi
fi

# --- Version Updated Path ---
if [ "$VERSION_UPDATED" = true ]; then
    echo -e "${GREEN}âœ“ [${REPO_NAME}] Version updated to ${CURRENT_VERSION}${NC}"

    # Quick PyPI check (5s timeout, non-blocking)
    PYPI_CHECK_RESULT=1
    if [ "$PACKAGE_NAME" != "unknown" ] && command -v python3 &> /dev/null; then
        python3 - "$PACKAGE_NAME" "$CURRENT_VERSION" <<'PY' && PYPI_CHECK_RESULT=0 || PYPI_CHECK_RESULT=$?
import json, sys, urllib.request
try:
    with urllib.request.urlopen(f"https://pypi.org/pypi/{sys.argv[1]}/json", timeout=5) as r:
        sys.exit(0 if sys.argv[2] in json.load(r).get("releases", {}) else 1)
except Exception:
    sys.exit(2)
PY
    fi

    if [ "$PYPI_CHECK_RESULT" -eq 0 ]; then
        echo -e "${YELLOW}âš  ${PACKAGE_NAME} ${CURRENT_VERSION} already on PyPI${NC}"
        echo -e "  ${GREEN}[u]${NC} Update version  ${YELLOW}[y]${NC} Continue  ${RED}[c]${NC} Cancel"
        echo -n "Choice [u/y/c]: "
        safe_read pypi_resp "y"

        if [[ "$pypi_resp" =~ ^[Uu]$ ]]; then
            echo -e "${YELLOW}Current: ${BLUE}${CURRENT_VERSION}${NC}"
            echo -n "New version: "
            safe_read new_version ""

            if [[ ! "$new_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
                echo -e "${RED}âœ— Invalid format (expected X.Y.Z or X.Y.Z.N)${NC}"
                exit 1
            fi

            old_version="$CURRENT_VERSION"
            if update_version "$CURRENT_VERSION" "$new_version"; then
                git commit -m "chore: bump version to ${new_version}"
                CURRENT_VERSION="$new_version"
                echo -e "${GREEN}âœ“ ${old_version} â†’ ${new_version}${NC}"
            else
                exit 1
            fi
        elif [[ "$pypi_resp" =~ ^[Cc]$ ]]; then
            echo -e "${YELLOW}Push cancelled${NC}"
            exit 1
        fi
    elif [ "$PYPI_CHECK_RESULT" -eq 2 ]; then
        echo -e "${DIM}(PyPI check skipped - network unavailable)${NC}"
    fi

    # Ask about publishing
    echo -e "${BLUE}ðŸ“¦ Publish ${CURRENT_VERSION} to PyPI after push? [Y/n/c]:${NC}"
    safe_read response "y"

    if [[ "$response" =~ ^[Cc]$ ]]; then
        echo -e "${YELLOW}Push cancelled${NC}"
        exit 1
    elif [[ "$response" =~ ^[Nn]$ ]]; then
        echo -e "${DIM}Skipping PyPI${NC}"
    else
        WANT_PUBLISH=true
    fi

# --- Version NOT Updated Path ---
else
    echo -e "${YELLOW}âš  [${REPO_NAME}] Version not updated (current: ${CURRENT_VERSION})${NC}"
    echo -e "  ${GREEN}[u]${NC} Update version  ${YELLOW}[y]${NC} Continue  ${RED}[n]${NC} Cancel"
    echo -n "Choice [u/y/n]: "
    safe_read response "y"

    if [[ "$response" =~ ^[Uu]$ ]]; then
        echo -e "${YELLOW}Current: ${BLUE}${CURRENT_VERSION}${NC}"
        echo -n "New version: "
        safe_read new_version ""

        if [[ ! "$new_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
            echo -e "${RED}âœ— Invalid format (expected X.Y.Z or X.Y.Z.N)${NC}"
            exit 1
        fi

        old_version="$CURRENT_VERSION"
        if update_version "$CURRENT_VERSION" "$new_version"; then
            git commit -m "chore: bump version to ${new_version}"
            CURRENT_VERSION="$new_version"
            echo -e "${GREEN}âœ“ ${old_version} â†’ ${new_version}${NC}"
        else
            exit 1
        fi

        echo -e "${BLUE}ðŸ“¦ Publish ${CURRENT_VERSION} to PyPI after push? [Y/n]:${NC}"
        safe_read upload_resp "y"
        if [[ ! "$upload_resp" =~ ^[Nn]$ ]]; then
            WANT_PUBLISH=true
        fi
    elif [[ "$response" =~ ^[Yy]$ ]]; then
        : # continue
    else
        echo -e "${YELLOW}Push cancelled${NC}"
        exit 1
    fi
fi

# Schedule background publish if requested (runs AFTER push completes)
if [ "$WANT_PUBLISH" = true ]; then
    schedule_post_push_publish "$CURRENT_VERSION" "$PACKAGE_NAME"
fi

# Exit 0 â†’ push proceeds immediately, never blocked by build/upload
exit 0
